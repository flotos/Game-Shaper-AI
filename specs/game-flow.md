# Game Flow Specification

## Overview
Game Shaper AI creates dynamic, interactive narrative experiences through a sophisticated flow that combines user input, AI generation, quality control, and state management. The system orchestrates multiple AI models to create coherent, engaging stories that evolve based on player choices.

## Core Interaction Loop

### 1. User Input Phase
- **Input Methods**:
  - Free-form text input in chat interface
  - Suggested action buttons generated by AI
  - Direct node manipulation through UI
  - File imports (Twine stories, save files)

- **Input Processing**:
  - Text validation and sanitization
  - Context preparation for AI processing
  - User intent analysis and categorization
  - Historical context integration

### 2. AI Processing Phase (Parallel Operations)

#### Primary LLM Operations (Synchronous)
```
User Input → Node Relevance Check → Chat Text Generation
                                         ↓
                              Action Generation ← Node Edition Generation
```

**Node Relevance Filtering**:
- Determines which nodes are relevant to current context
- Optimizes token usage by including only necessary information
- Uses GPT-3.5-turbo for fast, cost-effective processing
- Only triggered when node count exceeds VITE_MAX_INCLUDED_NODES (default: 15)

**Chat Text Generation**:
- Creates narrative response using GPT-4o
- Streams text in real-time for immediate user feedback
- Incorporates Moxus feedback as mandatory context
- Maintains story continuity and character consistency
- Uses last 5 interactions for context

**Action & Node Generation** (Parallel):
- **Actions**: Suggests 2 meaningful next steps for the user
- **Nodes**: Proposes game state changes using JSON structure (n_nodes, u_nodes, d_nodes)
- Uses comprehensive context including nodes, chat history, and Moxus guidance
- Both use GPT-4o for processing

#### Background Quality Control (Asynchronous)
```
Moxus Evaluation Flow:
Chat Text → Feedback → Memory Update (chatTextFeedback task)
Node Changes → Feedback → Memory Update (nodeEditFeedback task) → Final Report → General Memory Update
```

### 3. State Update Phase
- **Node Graph Updates**:
  - Apply approved node operations (create/update/delete)
  - Validate changes against business rules
  - Trigger image regeneration for modified nodes
  - Update node relevance sorting

- **Chat History Updates**:
  - Append new assistant response
  - Store user input with timestamp
  - Maintain conversation continuity
  - Integrate Moxus feedback when available

### 4. UI Synchronization Phase
- **Visual Updates**:
  - Refresh node grid with new/modified nodes
  - Update chat interface with new messages
  - Display suggested actions for next interaction
  - Show progress indicators for background operations

- **Image Processing**:
  - Queue image generation for updated nodes
  - Process images in batches to manage API limits
  - Update UI as images complete generation
  - Handle image generation errors gracefully

## Advanced Interaction Patterns

### Assistant-Driven Node Generation
1. **User Opens Assistant Overlay**
2. **Prompt Input**: User provides generation instructions
3. **Context Gathering**: System includes current nodes and Moxus memory
4. **Batch Generation**: AI creates multiple related nodes
5. **Preview & Approval**: User reviews before applying changes
6. **Integration**: New nodes merged into existing game state

### Twine Story Import
1. **File Upload**: User selects Twine story file
2. **Story Parsing**: Extract narrative elements and structure
3. **Element Analysis**: AI categorizes story components
4. **Node Mapping**: Convert story elements to game nodes
5. **Integration Options**: Merge with existing or create new game
6. **Validation**: Ensure consistency with existing content

### Game State Management
1. **Continuous Autosave**: Automatic localStorage persistence
2. **Export Functionality**: Complete game state download
3. **Import Capability**: Load saved game states
4. **Reset Options**: Clear chat only or complete reset
5. **Version Control**: Track changes for debugging

## Moxus Integration Flow

### Real-Time Quality Control
1. **Output Monitoring**: Moxus evaluates all AI generations
2. **Feedback Integration**: Critical feedback becomes mandatory context
3. **Memory Learning**: System improves based on past interactions
4. **Consistency Enforcement**: Maintains world rules and character integrity

### Feedback Loop Enhancement
```
User Action → AI Response → Moxus Evaluation → Memory Update → Enhanced Future Context
```

### Quality Assurance Checkpoints
- **Narrative Consistency**: Character behavior and world rules
- **Pacing Control**: Story rhythm and engagement levels
- **Technical Validation**: JSON structure and data integrity
- **User Experience**: Clarity and meaningful choice provision

## Error Handling and Recovery

### Graceful Degradation
- **LLM Service Failures**: Fallback to cached responses or simplified operations
- **Network Issues**: Queue operations for retry when connection restored
- **Memory Constraints**: Automatic cleanup and compression
- **Invalid Responses**: Error detection with user-friendly messages

### User Communication
- **Progress Indicators**: Clear feedback during long operations
- **Error Messages**: Helpful descriptions with suggested solutions
- **Status Updates**: Real-time information about system state
- **Recovery Options**: Alternative paths when primary operations fail

## Performance Optimization Strategies

### Token Management
- **Relevance Filtering**: Include only contextually important nodes
- **Context Compression**: Summarize lengthy histories when needed
- **Smart Caching**: Reuse results for similar inputs
- **Batch Processing**: Group related operations for efficiency

### Response Time Optimization
- **Parallel Processing**: Run independent operations simultaneously
- **Streaming Responses**: Display text as it generates
- **Background Operations**: Non-blocking quality control and image generation
- **Progressive Enhancement**: Show basic content immediately, enhance asynchronously

### Resource Management
- **Image Queue**: Batch image generation to respect rate limits
- **Memory Cleanup**: Regular garbage collection for blob URLs
- **Storage Optimization**: Compress saved data to manage quotas
- **API Cost Control**: Smart model selection based on operation complexity

## User Experience Patterns

### Engagement Mechanisms
- **Immediate Feedback**: Real-time response to user actions
- **Meaningful Choices**: AI-generated actions that matter to story progression
- **Visual Storytelling**: Images that enhance narrative immersion
- **Progressive Revelation**: Story elements that unfold naturally

### Accessibility Features
- **Multiple Input Methods**: Text, buttons, and visual interfaces
- **Clear Visual Hierarchy**: Organized information presentation
- **Error Recovery**: Multiple ways to accomplish tasks
- **Customization Options**: Adjustable UI and behavior settings

### Learning and Adaptation
- **User Preference Learning**: Moxus adapts to player style
- **Story Memory**: Consistent reference to past events
- **World Building**: Coherent universe development over time
- **Narrative Growth**: Stories that become richer with continued play

## Integration with External Systems

### AI Service Coordination
- **Multiple Providers**: Support for OpenAI, OpenRouter, KoboldCPP, and DeepSeek
- **Model Selection**: Appropriate models for different tasks
- **Fallback Chains**: Alternative providers when primary fails
- **Cost Optimization**: Balance quality with expense
- **Retry Logic**: 3 retry attempts with exponential backoff

### Data Portability
- **Export Formats**: JSON for compatibility and analysis
- **Import Standards**: Support for common narrative formats
- **Version Compatibility**: Handle changes in data structure
- **Cross-Platform Use**: Share games between different instances

## Development and Debugging

### Logging and Monitoring
- **LLM Call Tracking**: Detailed logs of all AI interactions
- **Performance Metrics**: Response times and resource usage
- **Error Analytics**: Pattern detection for system improvement
- **User Behavior**: Understanding how players engage with stories

### Testing and Validation
- **Automated Tests**: Verify core functionality
- **Manual Testing**: Human validation of narrative quality
- **Edge Case Handling**: Robust operation under unusual conditions
- **Performance Benchmarks**: Maintain acceptable response times

This game flow creates a seamless experience where users feel like they're collaborating with an intelligent storyteller that remembers everything, learns from interactions, and consistently creates engaging narrative experiences. 